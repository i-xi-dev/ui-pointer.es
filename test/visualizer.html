<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title></title>
    <link href="./asset/visualizer.css" rel="stylesheet" />
    <script type="module">
import { createApp, reactive } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";
import { PointerObserver } from "../dist/index.js";

const template = `
<div class="v-app">
  <div class="v-control">
    <button class="v-control-button v--pushbutton" @click="recording = !recording">
      <svg v-if="recording === true" viewBox="0 0 24 24">
        <path d="M 5 5 L 19 5 L 19 19 L 5 19 z" fill="#fff"/>
      </svg>
      <svg v-else viewBox="0 0 24 24">
        <path d="M 3 3 L 22 12 L 3 21 z" fill="#fff"/>
      </svg>
      <span>{{ (recording === true) ? "Stop" : "Start" }}</span>
    </button>
    <label :aria-disabled="recording === true ? 'true' : 'false'" class="v-control-button">
      <input :disabled="recording === true" type="checkbox" v-model="includesHover"/>
      <span>Include pointer hover in watch</span>
    </label>
    <fieldset class="v-control-group" :disabled="recording === true">
      <legend>Watch following pointer types</legend>
      <div class="v-control-flow">
        <label :aria-disabled="recording === true ? 'true' : 'false'" class="v-control-button">
          <input type="checkbox" v-model="watchMouse"/>
          <span>Mouse</span>
        </label>
        <label :aria-disabled="recording === true ? 'true' : 'false'" class="v-control-button">
          <input type="checkbox" v-model="watchPen"/>
          <span>Pen</span>
        </label>
        <label :aria-disabled="recording === true ? 'true' : 'false'" class="v-control-button">
          <input type="checkbox" v-model="watchTouch"/>
          <span>Touch</span>
        </label>
      </div>
    </fieldset>
    <label :aria-disabled="recording === true ? 'true' : 'false'" class="v-control-button">
      <input :disabled="recording === true" type="checkbox" v-model="usePointerCapture"/>
      <span>Pointer-capture when pointer is contacted</span>
    </label>
  </div>

  <div class="v-input-wrapper">
    <div class="v-input" ref="input1">
      <svg class="v-input-layers" v-if="drawMode === 'svg'" viewBox="0 0 400 400">
      </svg>
      <div class="v-input-layers" v-if="drawMode === 'canvas'">
        <canvas class="v-input-layer" height="400" :id="'canvas-' + layer" v-for="layer of layers" width="400"></canvas>
      </div>

      <div
      :class="{
        'v-input-indicator': true,
        'v--primary': indicator.primary === true,
        'v--contact': indicator.inContact === true,
        'v--mouse': indicator.type === 'mouse',
        'v--pen': indicator.type === 'pen',
        'v--touch': indicator.type === 'touch',
      }"
      :style="{
        'left': indicator.offsetX + 'px',
        'top': indicator.offsetY + 'px',
        '--width': indicator.width + 'px',
        '--height': indicator.height + 'px',
      }"
      v-for="indicator of indicators">
        <div class="v-input-indicator-crosshair"></div>
        <div class="v-input-indicator-circle"></div>
        <div class="v-input-indicator-contact"></div>
      </div>
    </div>
  </div>

  <div class="v-output">
  </div>
</div>
`;

createApp({
  data() {
    return {
      drawMode: "svg", // "svg" | "canvas"
      layerMap: new Map(),
      observer: null,
      indicatorMap: new Map(),
      idGen: (function*() {
        for (let i = 1; i <= Number.MAX_SAFE_INTEGER; i++) {
          yield i;
        }
        throw new Error("id overflow");
      })(),
      history: [],
      recording: false,
      usePointerCapture: false,
      includesHover: false,
      watchMouse: true,
      watchPen: true,
      watchTouch: true,
    };
  },

  template,

  computed: {
    layers() {
      return [...this.layerMap.keys()];
    },

    indicators() {
      return [...this.indicatorMap.values()];
    },
  },

  methods: {
    nextId() {
      return this.idGen.next().value;
    },

    onstart(activity) {
      const offsetX = activity.startTargetOffset.x;
      const offsetY = activity.startTargetOffset.y;

      let layerId;
      let layerContext;
      let path;
      if (this.drawMode === "canvas") {
        for (const entry of this.layerMap) {
          if (entry[1] !== true) {
            layerId = entry[0];
            this.layerMap.set(layerId, true);
            break;
          }
        }
        if (Number.isSafeInteger(layerId) !== true) {
          return;
        }
        layerContext = document.getElementById(`canvas-${layerId}`).getContext("2d");
        layerContext.lineWidth = 1;
        layerContext.strokeStyle = "#d12";
        layerContext.beginPath();
        layerContext.moveTo(offsetX, offsetY);
      }
      else if (this.drawMode === "svg") {
        path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.classList.add("v-input-layer-path");
        path.setAttribute("d", `M ${offsetX} ${offsetY}`);
        document.querySelector("*.v-input-layers").append(path);
      }

      const { pointer } = activity;
      const indicator = {
        id: this.nextId(),
        type: pointer.type,
        primary: pointer.isPrimary,
        name: `${ pointer.type }:${ pointer.id }`,
        offsetX,
        offsetY,
        width: 1,
        height: 1,
        inContact: false,
        layerId,
        layerContext,
        path,
      };
      this.indicatorMap.set(activity, indicator);
      this.history.push(indicator);
    },

    onend(activity) {
      const indicator = this.indicatorMap.get(activity);
      this.indicatorMap.delete(activity);

      if (this.drawMode === "canvas") {
        this.layerMap.set(indicator.layerId, false);
        //const { layerContext } = indicator.layerId;
        //layerContext.
      }
      else if (this.drawMode === "svg") {
        //
      }
    },

    onprogress(activity, motion) {
      const offsetX = motion.targetOffset.x;
      const offsetY = motion.targetOffset.y;
      const inContact = motion.inContact;

      const indicator = this.indicatorMap.get(activity);
      indicator.offsetX = offsetX;
      indicator.offsetY = offsetY;
      indicator.width = motion.properties.radiusX * 2;
      indicator.height = motion.properties.radiusY * 2;
      indicator.inContact = inContact;

      if (this.drawMode === "canvas") {
        const { layerContext } = indicator;
        if (inContact === true) {
          layerContext.lineTo(offsetX, offsetY);
        }
        else {
          layerContext.moveTo(offsetX, offsetY);
        }
        layerContext.stroke();
      }
      else if (this.drawMode === "svg") {
        const c = (inContact === true) ? "L" : "M";
        indicator.path.setAttribute("d", indicator.path.getAttribute("d") + ` ${c} ${offsetX} ${offsetY}`);
      }
    },
  },

  created() {
    if (this.drawMode === "canvas") {
      const l = 1 + (navigator.maxTouchPoints ? navigator.maxTouchPoints : 10);
      for (let i = 1; i <= l; i++) {
        this.layerMap.set(i, false);
      }
    }
  },

  mounted() {
    this.observer = new PointerObserver(async (activity) => {
      this.onstart(activity);
      for await (const motion of activity) {
        this.onprogress(activity, motion);
      }
      this.onend(activity);
    }, {
      includesHover: true,
    });
    console.log(this.$refs.input1.tagName)
    console.log(this.observer)
    this.observer.observe(this.$refs.input1);
  },

  beforeDestroy() {
    this.observer.disconnect();
  },

}).mount("#app");
    </script>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
